[{"title":"JavaScript--对象字面量","url":"/2022/04/12/JavaScript-%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F/","content":"创建一个对象\nvar obj = new Object();\n\n使用对象字面量来创建一个对象\nvar obj = &#123;&#125;;console.log(typeof obj);obj.name = &quot;孙悟空&quot;;console.log(obj.name);\n\n使用对象字面量，可以在创建对象时，直接指定对象中的属性\n语法：\n\n{属性名:属性值,属性名:属性值….}\n\n对象字面量的属性名可以加引号也可以不加，建议不加。\n\n如果要使用一些特殊的名字，则必须加引号\n\n属性名和属性值是一组一组的名值对结构\n\n名和值之间使用:连接，多个名值对之间使用,隔开\n\n如果一个属性之后没有其他的属性了，就不要写\n\n var obj2 = &#123;\tname:&quot;猪八戒&quot;,    age:13,    gender:&quot;男&quot;,    test:&#123;name:&quot;沙僧&quot;&#125;\t&#125;;\tconsole.log(obj2.test);\n\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"JavaScript--对象","url":"/2022/04/12/JavaScript-%E5%AF%B9%E8%B1%A1/","content":"JS中数据类型String 字符串Number 数值Boolean 布尔值Null 空值Undefined 未定义以上这五种类型属于基本数据类型，以后我们看到的值只要不是上边的5种，全都是对象\nObject 对象基本数据类型都是单一的值”hello” 123 true值和值之间没有任何的联系。\n在JS中来表示一个人的信息（name gender age）\nvar name = &quot;孙悟空&quot;;var gender = &quot;男&quot;;var age = 18;\n\n如果使用基本数据类型的数据，我们所创建的变量都是独立，不能成为一个整体。对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。\n对象的分类1.内建对象由ES标准中定义的对象，在任何的ES的实现中都可以使用\n比如：Math String Number Boolean Function Object….\n2.宿主对象由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象\n比如 BOM DOM\n3.自定义对象由开发人员自己创建的对象\n创建对象使用new关键字调用的函数，是构造函数constructor\n构造函数是专门用来创建对象的函数\n使用typeof检查一个对象时，会返回object\nvar obj = new Object();\n\n在对象中保存的值称为属性向对象添加属性\n\n语法：对象.属性名 &#x3D; 属性值;\n\n//向obj中添加一个name属性obj.name = &quot;孙悟空&quot;;//向obj中添加一个gender属性obj.gender = &quot;男&quot;;//向obj中添加一个age属性obj.age = 18;\n\n读取对象中的属性语法：\n\n对象.属性名\n\n如果读取对象中没有的属性，不会报错而是会返回undefined\nconsole.log(obj.gender);console.log(obj.hello);\n\n修改对象的属性值语法：\n\n对象.属性名 &#x3D; 新值\n\nobj.name = &quot;tom&quot;;\n\n删除对象的属性语法：\n\ndelete 对象.属性名\n\ndelete obj.name;\n\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"JavaScript--基本数据类型和引用数据类型","url":"/2022/04/12/JavaScript-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"基本数据类型\nString\nNumber \nBoolean \nNull \nUndefined\n\n引用数据类型\nObject\n\nJS中的变量都是保存到栈内存中的，基本数据类型的值直接在栈内存中存储，值与值之间是独立存在，修改一个变量不会影响其他的变量。\n对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响。\nvar a = 123;var b = a;    a++;\t\tconsole.log(&quot;a = &quot;+a);console.log(&quot;b = &quot;+b);\n\nvar obj = new Object();obj.name = &quot;孙悟空&quot;;\t\t\tvar obj2 = obj;//修改obj的name属性obj.name = &quot;猪八戒&quot;;console.log(obj.name);console.log(obj2.name);//设置obj2为nullobj2 = null;console.log(obj);console.log(obj2);var c = 10;var d = 10;console.log(c == d);var obj3 = new Object();var obj4 = new Object();obj3.name = &quot;沙和尚&quot;;obj4.name = &quot;沙和尚&quot;;console.log(obj3);console.log(obj4);\n\n当比较两个基本数据类型的值时，就是比较值。而比较两个引用数据类型时，它是比较的对象的内存地址。如果两个对象是一摸一样的，但是地址不同，它也会返回false。\nconsole.log(obj3 == obj4);\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"JavaScript--属性名与属性值","url":"/2022/04/12/JavaScript-%E5%B1%9E%E6%80%A7%E5%90%8D%E4%B8%8E%E5%B1%9E%E6%80%A7%E5%80%BC/","content":"var obj = new Object();\n\n向对象中添加属性 * 属性名：\n \n- 对象的属性名不强制要求遵守标识符的规范\n\n- 什么乱七八糟的名字都可以使用\n- 但是我们使用是还是尽量按照标识符的规范去做\n\nobj.name = &quot;孙悟空&quot;;obj.var = &quot;hello&quot;;\n\n如果要使用特殊的属性名，不能采用.的方式来操作需要使用另一种方式：语法：\n\n对象[“属性名”] &#x3D; 属性值\n\n读取时也需要采用这种方式使用[]这种形式去操作属性，更加的灵活在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性\nobj[&quot;123&quot;] = 789;obj[&quot;nihao&quot;] = &quot;你好&quot;;var n = &quot;nihao&quot;;console.log(obj[&quot;123&quot;]);\n\n属性值\nJS对象的属性值，可以是任意的数据类型\n\n甚至也可以是一个对象\n\n\nobj.test = true;obj.test = null;obj.test = undefined;//创建一个对象var obj2 = new Object();obj2.name = &quot;猪八戒&quot;;//将obj2设置为obj的属性obj.test = obj2;console.log(obj.test.name);\n\nin 运算符通过该运算符可以检查一个对象中是否含有指定的属性\n如果有则返回true，没有则返回false\n语法：\n\n“属性名” in 对象\n\n//检查obj中是否含有test2属性console.log(&quot;test2&quot; in obj);console.log(&quot;test&quot; in obj);console.log(&quot;name&quot; in obj);\n","categories":["前端","JavaScript"],"tags":["js","js基础","属性"]},{"title":"Hello World","url":"/2022/04/06/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"javascript--this关键字","url":"/2022/04/21/javascript-this%E5%85%B3%E9%94%AE%E5%AD%97/","content":"解析器在调用函数每次都会向函数内部传递进一个隐含的参数\n这个隐含的参数就是this，this指向的是一个对象。\n这个对象我们称为函数执行的 上下文对象。\n根据函数的调用方式的不同，this会指向不同的对象\n1.以函数的形式调用时，this永远都是window\n2.以方法的形式调用时，this就是调用方法的那个对象\n//创建一个name变量\t\t\tvar name = &quot;全局&quot;;\t\t\t\t\t\t//创建一个fun()函数\t\t\tfunction fun()&#123;\t\t\t\tconsole.log(this.name);\t\t\t&#125;\t\t\t\t\t\t//创建两个对象\t\t\tvar obj = &#123;\t\t\t\t\tname:&quot;孙悟空&quot;,\t\t\t\t\tsayName:fun\t\t\t&#125;;\t\t\t\t\t\tvar obj2 = &#123;\t\t\t\t\tname:&quot;沙和尚&quot;,\t\t\t\t\tsayName:fun\t\t\t&#125;;\t\t\t\t\t\t//我们希望调用obj.sayName()时可以输出obj的名字\t\t\t//obj.sayName();\t\t\t\t\t\tobj.sayName();\n\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"javascript--toString","url":"/2022/04/29/javascript-toString/","content":"function Person(name , age , gender)&#123;\t\t\t\tthis.name = name;\t\t\t\tthis.age = age;\t\t\t\tthis.gender = gender;\t\t\t&#125;\t\t\t\t\t\t//修改Person原型的toString\t\t\tPerson.prototype.toString = function()&#123;\t\t\t\treturn &quot;Person[name=&quot;+this.name+&quot;,age=&quot;+this.age+&quot;,gender=&quot;+this.gender+&quot;]&quot;;\t\t\t&#125;;\t\t\t\t\t\t\t\t\t//创建一个Person实例\t\t\tvar per = new Person(&quot;孙悟空&quot;,18,&quot;男&quot;);\t\t\tvar per2 = new Person(&quot;猪八戒&quot;,28,&quot;男&quot;);\t\t\t\t\t\t//当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值\t\t\t//如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法\t\t\t//Person[name=孙悟空,age=18,gender=男]\t\t\t/*per.toString = function()&#123;\t\t\t\treturn &quot;Person[name=&quot;+this.name+&quot;,age=&quot;+this.age+&quot;,gender=&quot;+this.gender+&quot;]&quot;;\t\t\t&#125;;*/\t\t\t\t\t\tvar result = per.toString();\t\t\t//console.log(&quot;result = &quot; + result);\t\t\t//console.log(per.__proto__.__proto__.hasOwnProperty(&quot;toString&quot;));\t\t\tconsole.log(per2);\t\t\tconsole.log(per);\n\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"javascript作用域（scope）","url":"/2022/04/15/javascript-%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88scope%EF%BC%89/","content":"作用域作用域指一个变量的作用的范围\n在JS中一共有两种作用域：\n全局作用域\n直接编写在script标签中的JS代码，都在全局作用域\n全局作用域在页面打开时创建，在页面关闭时销毁\n在全局作用域中有一个全局对象window，\n它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用\n\n在全局作用域中：\n\n创建的变量都会作为window对象的属性保存\n创建的函数都会作为window对象的方法保存\n全局作用域中的变量都是全局变量\n在页面的任意的部分都可以访问的到\n\nvar a = 10;var b = 20;var c = &quot;hello&quot;;    console.log(window.c);    function fun()&#123;    console.log(&quot;我是fun函数&quot;);    &#125;    //window.fun();\t\t    //window.alert(&quot;hello&quot;);\n\n\n\n函数作用域调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁\n每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的\n在函数作用域中可以访问到全局作用域的变量\n在全局作用域中无法访问到函数作用域的变量\n当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用\n如果没有则向上一级作用域中寻找，直到找到全局作用域，\n如果全局作用域中依然没有找到，则会报错ReferenceError\n在函数中要访问全局变量可以使用window对象\nvar a = 10;\t\t\t\t\t\tfunction fun()&#123;\t\t\t\t\t\t\t\tvar a = &quot;我是fun函数中的变量a&quot;;\t\t\t\tvar b = 20;\t\t\t\t\t\t\t\t//console.log(&quot;a = &quot;+a);\t\t\t\t\t\t\t\tfunction fun2()&#123;\t\t\t\t\tconsole.log(&quot;a = &quot;+window.a);\t\t\t\t&#125;\t\t\t\t\t\t\t\tfun2();\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t//fun();\t\t\t//console.log(&quot;b = &quot;+b);\t\t\t\t\t\t/*\t\t\t * 在函数作用域也有声明提前的特性，\t\t\t * \t使用var关键字声明的变量，会在函数中所有的代码执行之前被声明\t\t\t * \t函数声明也会在函数中所有的代码执行之前执行\t\t\t */\t\t\t\t\t\tfunction fun3()&#123;\t\t\t\t\t\t\t\tfun4();\t\t\t\t\t\t\t\t//console.log(a);\t\t\t\t\t\t\t\tvar a = 35;\t\t\t\t\t\t\t\tfunction fun4()&#123;\t\t\t\t\talert(&quot;I&#x27;m fun4&quot;);\t\t\t\t&#125;\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t//fun3();\t\t\t\t\t\t\t\t\tvar c = 33;\t\t\t\t\t\t/*\t\t\t * 在函数中，不适用var声明的变量都会成为全局变量\t\t\t */\t\t\tfunction fun5()&#123;\t\t\t\t//console.log(&quot;c = &quot;+c);\t\t\t\t//c = 10;\t\t\t\t\t\t\t\t//d没有使用var关键字，则会设置为全局变量\t\t\t\td = 100;\t\t\t&#125;\t\t\t\t\t\tfun5();\t\t\t\t\t\t//在全局输出c\t\t\t//console.log(&quot;d = &quot;+d);\t\t\t\t\t\tvar e = 23;\t\t\t\t\t\t/*\t\t\t * 定义形参就相当于在函数作用域中声明了变量\t\t\t */\t\t\tfunction fun6(e)&#123;\t\t\t\talert(e);\t\t\t&#125;\t\t\t\t\t\tfun6();\n\n","tags":["js js基础"]},{"title":"javascript--函数","url":"/2022/04/13/javascript-%E5%87%BD%E6%95%B0/","content":"函数 function\n函数也是一个对象\n函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码）\n函数中可以保存一些代码在需要的时候调用\n使用typeof检查一个函数对象时，会返回function\n\n创建一个函数对象可以将要封装的代码以字符串的形式传递给构造函数\nvar fun = new Function(&quot;console.log(&#x27;Hello 这是我的第一个函数&#x27;);&quot;);\n\n\n我们在实际开发中很少使用构造函数来创建一个函数对象。\n\n封装到函数中的代码不会立即执行\n函数中的代码会在函数调用的时候执行\n调用函数 语法：\n\n函数对象()\n\n当调用函数时，函数中封装的代码会按照顺序执行\nfun();\n\n使用 函数声明 来创建一个函数\n语法：\n\nfunction 函数名([形参1,形参2…形参N]){    语句…}\n\nfunction fun2()&#123;    console.log(&quot;这是我的第二个函数~&quot;);    alert(&quot;哈哈哈哈哈&quot;);    document.write(&quot;(&gt;_&lt;)~~&quot;);    &#125;\n\n 使用 函数表达式 来创建一个函数\n\nvar 函数名  &#x3D; function([形参1,形参2…形参N]){            语句….            }\n\nvar fun3 = function()&#123;    console.log(&quot;我是匿名函数中封装的代码&quot;);    &#125;;    fun3();\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"javascript--函数的参数","url":"/2022/04/13/javascript-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/","content":"定义一个用来求两个数和的函数\n可以在函数的()中来指定一个或多个形参（形式参数）\n多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量\n但是并不赋值\n\nfunction sum(a,b)&#123;    console.log(&quot;a = &quot;+a);    console.log(&quot;b = &quot;+b);    console.log(a+b);    &#125;\n\n在调用函数时，可以在()中指定实参（实际参数）\n实参将会赋值给函数中对应的形参\nsum(1,2);sum(123,456);\n\n调用函数时解析器不会检查实参的类型，所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查。\n函数的实参可以是任意的数据类型\nsum(123,&quot;hello&quot;);sum(true,false);\n\n调用函数时，解析器也不会检查实参的数量\n多余实参不会被赋值\n如果实参的数量少于形参的数量，则没有对应实参的形参将是 undefined\nsum(123,456,&quot;hello&quot;,true,null);sum(123);\n\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"javascript--原型","url":"/2022/04/29/javascript-%E5%8E%9F%E5%9E%8B/","content":"原型 prototype我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype\n这个属性对应着一个对象，这个对象就是我们所谓的原型对象\n如果函数作为普通函数调用prototype没有任何作用\n当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过proto来访问该属性。\n原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。\n 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。\nfunction MyClass()&#123;\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t//向MyClass的原型中添加属性a\t\t\tMyClass.prototype.a = 123;\t\t\t\t\t\t//向MyClass的原型中添加一个方法\t\t\tMyClass.prototype.sayHello = function()&#123;\t\t\t\talert(&quot;hello&quot;);\t\t\t&#125;;\t\t\t\t\t\tvar mc = new MyClass();\t\t\t\t\t\tvar mc2 = new MyClass();\t\t\t\t\t\t//console.log(MyClass.prototype);\t\t\t//console.log(mc2.__proto__ == MyClass.prototype);\t\t\t\t\t\t//向mc中添加a属性\t\t\tmc.a = &quot;我是mc中的a&quot;;\t\t\t\t\t\t//console.log(mc2.a);\t\t\t\t\t\tmc.sayHello();\n\n创建一个构造函数\nfunction MyClass()&#123;&#125;//向MyClass的原型中添加一个name属性MyClass.prototype.name = &quot;我是原型中的名字&quot;;var mc = new MyClass();mc.age = 18;//console.log(mc.name);\n\n//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true\t\t\t//console.log(&quot;name&quot; in mc);\t\t\t\t\t//可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性\t\t//使用该方法只有当对象自身中含有属性时，才会返回true\t\t//console.log(mc.hasOwnProperty(&quot;age&quot;));\t\t\t\t//console.log(mc.hasOwnProperty(&quot;hasOwnProperty&quot;));\n\n\n原型对象也是对象，所以它也有原型，当我们使用一个对象的属性或方法时，会现在自身中寻找，自身中如果有，则直接使用，如果没有则去原型对象中寻找，如果原型对象中有，则使用，如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"javascript--对象（2）","url":"/2022/04/15/javascript-%E5%AF%B9%E8%B1%A1%EF%BC%882%EF%BC%89/","content":"创建一个对象\nvar obj = new Object();\n\n向对象中添加属性\nobj.name = &quot;孙悟空&quot;;obj.age = 18;\n\n\n对象的属性值可以是任何的数据类型，也可以是个函数\nobj.sayName = function()&#123;console.log(obj.name);    &#125;;function fun()&#123;    console.log(obj.name);    &#125;;//console.log(obj.sayName);//调方法obj.sayName();//调函数//fun();\n\n函数也可以称为对象的属性，如果一个函数作为一个对象的属性保存，那么我们称这个函数时这个对象的方法\n调用这个函数就说调用对象的方法（method）但是它只是名称上的区别没有其他的区别。\nvar obj2 = &#123;\t\tname:&quot;猪八戒&quot;,\tage:18,\tsayName:function()&#123;\t\tconsole.log(obj2.name);\t&#125;\t&#125;;obj2.sayName();\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"javascript--变量的声明提前","url":"/2022/04/21/javascript-%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D/","content":"变量的声明提前使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），但是如果声明变量时不适用var关键字，则变量不会被声明提前\n函数的声明提前使用函数声明形式创建的函数 function 函数(){}它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用\n//函数声明，会被提前创建function fun()&#123;\tconsole.log(&quot;我是一个fun函数&quot;);&#125;//函数表达式，不会被提前创建var fun2 = function()&#123;\tconsole.log(&quot;我是fun2函数&quot;);&#125;;fun2();\n\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"javascript--对象（3）","url":"/2022/04/21/javascript-%E5%AF%B9%E8%B1%A1%EF%BC%883%EF%BC%89/","content":"普通创建对象方法/* * 创建一个对象 */    var obj = &#123;        name:&quot;孙悟空&quot;,        age:18,        gender:&quot;男&quot;,        sayName:function()&#123;        alert(this.name);        &#125;    &#125;;\n\n使用工厂方法创建对象通过该方法可以大批量的创建对象\n\tfunction createPerson(name , age ,gender)&#123;\t//创建一个新的对象 \tvar obj = new Object();\t//向对象中添加属性\tobj.name = name;\tobj.age = age;\tobj.gender = gender;\tobj.sayName = function()&#123;\t\talert(this.name);\t&#125;;\t//将新的对象返回\treturn obj;&#125;\t/*\t * 用来创建狗的对象\t */\tfunction createDog(name , age)&#123;\t\tvar obj = new Object();\t\tobj.name = name;\t\tobj.age = age;\t\tobj.sayHello = function()&#123;\t\t\talert(&quot;汪汪~~&quot;);\t\t&#125;;\t\t\t\treturn obj;\t&#125;\t\tvar obj2 = createPerson(&quot;猪八戒&quot;,28,&quot;男&quot;);\tvar obj3 = createPerson(&quot;白骨精&quot;,16,&quot;女&quot;);\tvar obj4 = createPerson(&quot;蜘蛛精&quot;,18,&quot;女&quot;);\t/*\t * 使用工厂方法创建的对象，使用的构造函数都是Object\t * \t所以创建的对象都是Object这个类型，\t * \t就导致我们无法区分出多种不同类型的对象\t */\t//创建一个狗的对象\tvar dog = createDog(&quot;旺财&quot;,3);\t\tconsole.log(dog);\tconsole.log(obj4);\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"javascript--构造函数","url":"/2022/04/29/javascript-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","content":"创建一个构造函数，专门用来创建Person对象的\n构造函数就是一个普通的函数，创建方式和普通函数没有区别,\n不同的是构造函数习惯上首字母大写\n构造函数和普通函数的区别就是调用方式的不同\n普通函数是直接调用，而构造函数需要使用new关键字来调用\n构造函数的执行流程\n立刻创建一个新的对象\n将新建的对象设置为函数中this,在构造函数中可以使用this来引用新建的对象\n逐行执行函数中的代码\n将新建的对象作为返回值返回\n\n使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。\n我们将通过一个构造函数创建的对象，称为是该类的实例\nthis的情况\n当以函数的形式调用时，this是window\n\n当以方法的形式调用时，谁调用方法this就是谁\n\n当以构造函数的形式调用时，this就是新创建的那个对象\nfunction Person(name , age , gender)&#123;this.name = name;this.age = age;this.gender = gender;this.sayName = function()&#123;\talert(this.name);&#125;;&#125;\n\nfunction Dog()&#123;\t&#125;var per = new Person(&quot;孙悟空&quot;,18,&quot;男&quot;);var per2 = new Person(&quot;玉兔精&quot;,16,&quot;女&quot;);var per3 = new Person(&quot;奔波霸&quot;,38,&quot;男&quot;);var dog = new Dog();/*console.log(per);console.log(dog);*//* * 使用instanceof可以检查一个对象是否是一个类的实例 * \t语法： * \t\t对象 instanceof 构造函数 * 如果是，则返回true，否则返回false *///console.log(per instanceof Person);//console.log(dog instanceof Person);/* * 所有的对象都是Object的后代， * \t所以任何对象和Object左instanceof检查时都会返回true *///console.log(dog instanceof Object);\n\n/* * 创建一个Person构造函数 * \t- 在Person构造函数中，为每一个对象都添加了一个sayName方法， * \t\t目前我们的方法是在构造函数内部创建的， * \t\t\t也就是构造函数每执行一次就会创建一个新的sayName方法 * \t\t也是所有实例的sayName都是唯一的。 * \t\t这样就导致了构造函数执行一次就会创建一个新的方法， * \t\t\t执行10000次就会创建10000个新的方法，而10000个方法都是一摸一样的 * \t\t\t这是完全没有必要，完全可以使所有的对象共享同一个方法 */function Person(name , age , gender)&#123;\tthis.name = name;\tthis.age = age;\tthis.gender = gender;\t//向对象中添加一个方法\t//this.sayName = fun;&#125;//将sayName方法在全局作用域中定义/* * 将函数定义在全局作用域，污染了全局作用域的命名空间 * \t而且定义在全局作用域中也很不安全 *//*function fun()&#123;\talert(&quot;Hello大家好，我是:&quot;+this.name);&#125;;*///向原型中添加sayName方法Person.prototype.sayName = function()&#123;\talert(&quot;Hello大家好，我是:&quot;+this.name);&#125;;//创建一个Person的实例var per = new Person(&quot;孙悟空&quot;,18,&quot;男&quot;);var per2 = new Person(&quot;猪八戒&quot;,28,&quot;男&quot;);per.sayName();per2.sayName();//console.log(per.sayName == per2.sayName);\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"javascript--枚举对象中的属性","url":"/2022/04/15/javascript-%E6%9E%9A%E4%B8%BE%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7/","content":"var obj = &#123;    name:&quot;孙悟空&quot;,    age:18,    gender:&quot;男&quot;,    address:&quot;花果山&quot;     &#125;;\n\n枚举对象中的属性使用for … in 语句\n语法：\n\nfor(var 变量 in 对象){\n }\n\nfor…in语句 对象中有几个属性，循环体就会执行几次\n每次执行时，会将对象中的一个属性的名字赋值给变量\nfor(var n in obj)&#123;    console.log(&quot;属性名:&quot;+n);    console.log(&quot;属性值:&quot;+obj[n]);&#125;\n\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"javascript--立即执行函数","url":"/2022/04/13/javascript-%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/","content":"函数对象()\n立即执行函数\n函数定义完，立即被调用，这种函数叫做立即执行函数\n立即执行函数往往只会执行一次\n\n(function(){\n​    alert(“我是一个匿名函数~~~”);\n​    })();\n\n(function(a,b)&#123;    console.log(&quot;a = &quot;+a);    console.log(&quot;b = &quot;+b);    &#125;)(123,456);\n\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"javascript--返回值（return）","url":"/2022/04/13/javascript-%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%88return%EF%BC%89/","content":" 创建一个函数，用来计算三个数的和\n可以使用 return 来设置函数的返回值\n语法：\n\nreturn 值\n\n\nreturn后的值将会会作为函数的执行结果返回\n可以定义一个变量，来接收该结果\n在函数中return后的语句都不会执行\n如果return语句后不跟任何值就相当于返回一个undefined\n如果函数中不写return，则也会返回undefined\nreturn后可以跟任意类型的值\n\nfunction sum(a , b , c)&#123;    alert(a + b +c);    var d = a + b + c;    return d;    return undefined;&#125;\n\n调用函数\n\n变量result的值就是函数的执行结果\n函数返回什么result的值就是什么\n\nvar result = sum(4,7,8);var result = alert(&quot;hello&quot;);console.log(&quot;result = &quot;+result);\n\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"javascript--返回值（return）【实例】","url":"/2022/04/13/javascript-%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%88return%EF%BC%89%E3%80%90%E5%AE%9E%E4%BE%8B%E3%80%91/","content":"判断是否为偶数function fun()&#123;    alert(&quot;函数要执行了~~~~&quot;);    for(var i=0 ; i&lt;5 ; i++)&#123;\tif(i == 2)&#123;\t//使用break可以退出当前的循环\t//break;\t//continue用于跳过当次循环\t//continue;\t//使用return可以结束整个函数\treturn;\t&#125;\tconsole.log(i);\t&#125;\talert(&quot;函数执行完了~~~~&quot;);\t&#125;\t\tfun();\n\n\n\n返回值可以是任意的数据类型\n也可以是一个对象，也可以是一个函数\nfunction fun2()&#123;\t//返回一个对象\treturn &#123;name:&quot;沙和尚&quot;&#125;;\t&#125;\tvar a = fun2();\tconsole.log(&quot;a = &quot;+a);\tfunction fun3()&#123;\t//在函数内部再声明一个函数\tfunction fun4()&#123;\talert(&quot;我是fun4&quot;);\t&#125;\t//将fun4函数对象作为返回值返回\treturn fun4;\ta = fun3();\t//console.log(a);\t//a();\tfun3()();\n\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"算法设计与分析--最大字段和问题【动态规划法】","url":"/2022/04/09/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E6%9C%80%E5%A4%A7%E5%AD%97%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95%E3%80%91/","content":"问题引入\n什么是最大字段和问题？\n\n给定由 n 个整数（可能为负整数）组成的序列a1，a2，a3…an，求该数列中连续子段和最大！\n  例如：当（a1，a2，a3，a4，a5）&#x3D;（-2,11，-4,13，-5，-2）时，最大字段和为 20 （11 + (-4) + 13）;\n条件递推\n\nD[i]表示从i开始的最大字段和。（但我们不是从前往后找字段结束位置）根据递推公式，我们可知要想求得D[i],就必须知道D[i+1],所以我们从前往后计算。如下图：以i&#x3D;12开始的子段和D[12]&#x3D;X[12]&#x3D;-1，该子段结束位置Rec[12]&#x3D;i&#x3D;12；当i&#x3D;11时，D[11+1]&lt;0,所以D[11]&#x3D;X[11]&#x3D;7,Rec[i]&#x3D;i&#x3D;11;当i&#x3D;10时，D[10+1]&gt;0,所以D[10]&#x3D;X[10]+D[11]&#x3D;3+7,Rec&#x3D;i+1&#x3D;11;…\n\n\n\n代码实现#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//动态规划函数 接收数组和数组个数void dynamicPlan(int a[],int n)&#123;    //定义三个数组    //sum数组用于记录累加结果    //endRecord数组用于记录结束位置    int sum[n],endRecord[n];    //初始化sum数组最后一个值    sum[n] = a[n];    //初始化记录结束位置的数组    endRecord[n] = n;    //从右往左的计算值    for(int i = n - 1;i &gt;= 0;i--)&#123;    //情况1：如果i + 1的数大于0 sum数组记录下i + （i+1）的数    //endRecord记录下结束位置的值    if(sum[i + 1] &gt; 0)&#123;        sum[i] = a[i] + sum[i + 1];        endRecord[i] = endRecord[i + 1];    //情况2：当i + 1的数小于0时    //值为a数组本身的值    //结尾位置变为i    &#125;else&#123;        sum[i] = a[i];        endRecord[i] = i;        &#125;    &#125;    printf(&quot;累加和数组为：&quot;);    for(int i = 0;i &lt;= n ;i++)    printf(&quot;%d &quot;,sum[i]);    //查找结果函数    findResult(n,a,sum,endRecord);&#125;void findResult(int n,int a[],int sum[],int endRecord[])&#123;    int max,l,r,i;    //从左往右开始查找    //max初始化为sum数组第一个值    max = sum[0];    //和sum数组第二个值开始比对    for(i = 1;i &lt;= n;i++)&#123;    if(max &lt; sum[i])&#123;        max = sum[i];        l = i;        r = endRecord[i];    &#125;&#125;printf(&quot;\\n原数组为：&quot;);for(i = 0;i &lt;= n ; i++)    printf(&quot;%d &quot;,a[i]);printf(&quot;\\n最大字段和为：%d 开始位置的数组下标：%d 结束位置的数组下标：%d&quot;,max,l,r);&#125;int main()&#123;    //这里可以改为输入的方式    int n=11;\tint a[]=&#123;1,-2,4,5,-2,8,3,-2,6,3,7,-1&#125;;\tdynamicPlan(a,n);&#125;\n\n","categories":["算法设计与分析"],"tags":["算法","动态规划"]}]