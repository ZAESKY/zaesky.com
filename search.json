[{"title":"JavaScript--对象","url":"/2022/04/12/JavaScript-%E5%AF%B9%E8%B1%A1/","content":"JS中数据类型String 字符串Number 数值Boolean 布尔值Null 空值Undefined 未定义以上这五种类型属于基本数据类型，以后我们看到的值只要不是上边的5种，全都是对象\nObject 对象基本数据类型都是单一的值”hello” 123 true值和值之间没有任何的联系。\n在JS中来表示一个人的信息（name gender age）\nvar name = &quot;孙悟空&quot;;var gender = &quot;男&quot;;var age = 18;\n\n如果使用基本数据类型的数据，我们所创建的变量都是独立，不能成为一个整体。对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。\n对象的分类1.内建对象由ES标准中定义的对象，在任何的ES的实现中都可以使用\n比如：Math String Number Boolean Function Object….\n2.宿主对象由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象\n比如 BOM DOM\n3.自定义对象由开发人员自己创建的对象\n创建对象使用new关键字调用的函数，是构造函数constructor\n构造函数是专门用来创建对象的函数\n使用typeof检查一个对象时，会返回object\nvar obj = new Object();\n\n在对象中保存的值称为属性向对象添加属性\n\n语法：对象.属性名 &#x3D; 属性值;\n\n//向obj中添加一个name属性obj.name = &quot;孙悟空&quot;;//向obj中添加一个gender属性obj.gender = &quot;男&quot;;//向obj中添加一个age属性obj.age = 18;\n\n读取对象中的属性语法：\n\n对象.属性名\n\n如果读取对象中没有的属性，不会报错而是会返回undefined\nconsole.log(obj.gender);console.log(obj.hello);\n\n修改对象的属性值语法：\n\n对象.属性名 &#x3D; 新值\n\nobj.name = &quot;tom&quot;;\n\n删除对象的属性语法：\n\ndelete 对象.属性名\n\ndelete obj.name;\n\n","categories":["前端","JavaScript"],"tags":["js","js基础"]},{"title":"JavaScript--属性名与属性值","url":"/2022/04/12/JavaScript-%E5%B1%9E%E6%80%A7%E5%90%8D%E4%B8%8E%E5%B1%9E%E6%80%A7%E5%80%BC/","content":"var obj = new Object();\n\n向对象中添加属性 * 属性名：\n \n- 对象的属性名不强制要求遵守标识符的规范\n\n- 什么乱七八糟的名字都可以使用\n- 但是我们使用是还是尽量按照标识符的规范去做\n\nobj.name = &quot;孙悟空&quot;;obj.var = &quot;hello&quot;;\n\n如果要使用特殊的属性名，不能采用.的方式来操作需要使用另一种方式：语法：\n\n对象[“属性名”] &#x3D; 属性值\n\n读取时也需要采用这种方式使用[]这种形式去操作属性，更加的灵活在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性\nobj[&quot;123&quot;] = 789;obj[&quot;nihao&quot;] = &quot;你好&quot;;var n = &quot;nihao&quot;;console.log(obj[&quot;123&quot;]);\n\n属性值\nJS对象的属性值，可以是任意的数据类型\n\n甚至也可以是一个对象\n\n\nobj.test = true;obj.test = null;obj.test = undefined;//创建一个对象var obj2 = new Object();obj2.name = &quot;猪八戒&quot;;//将obj2设置为obj的属性obj.test = obj2;console.log(obj.test.name);\n\nin 运算符通过该运算符可以检查一个对象中是否含有指定的属性\n如果有则返回true，没有则返回false\n语法：\n\n“属性名” in 对象\n\n//检查obj中是否含有test2属性console.log(&quot;test2&quot; in obj);console.log(&quot;test&quot; in obj);console.log(&quot;name&quot; in obj);\n","categories":["前端","JavaScript"],"tags":["js","js基础","属性"]},{"title":"Hello World","url":"/2022/04/06/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"算法设计与分析--最大字段和问题【动态规划法】","url":"/2022/04/09/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E6%9C%80%E5%A4%A7%E5%AD%97%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95%E3%80%91/","content":"问题引入\n什么是最大字段和问题？\n\n给定由 n 个整数（可能为负整数）组成的序列a1，a2，a3…an，求该数列中连续子段和最大！\n  例如：当（a1，a2，a3，a4，a5）&#x3D;（-2,11，-4,13，-5，-2）时，最大字段和为 20 （11 + (-4) + 13）;\n条件递推\n\nD[i]表示从i开始的最大字段和。（但我们不是从前往后找字段结束位置）根据递推公式，我们可知要想求得D[i],就必须知道D[i+1],所以我们从前往后计算。如下图：以i&#x3D;12开始的子段和D[12]&#x3D;X[12]&#x3D;-1，该子段结束位置Rec[12]&#x3D;i&#x3D;12；当i&#x3D;11时，D[11+1]&lt;0,所以D[11]&#x3D;X[11]&#x3D;7,Rec[i]&#x3D;i&#x3D;11;当i&#x3D;10时，D[10+1]&gt;0,所以D[10]&#x3D;X[10]+D[11]&#x3D;3+7,Rec&#x3D;i+1&#x3D;11;…\n\n\n\n代码实现#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//动态规划函数 接收数组和数组个数void dynamicPlan(int a[],int n)&#123;    //定义三个数组    //sum数组用于记录累加结果    //endRecord数组用于记录结束位置    int sum[n],endRecord[n];    //初始化sum数组最后一个值    sum[n] = a[n];    //初始化记录结束位置的数组    endRecord[n] = n;    //从右往左的计算值    for(int i = n - 1;i &gt;= 0;i--)&#123;    //情况1：如果i + 1的数大于0 sum数组记录下i + （i+1）的数    //endRecord记录下结束位置的值    if(sum[i + 1] &gt; 0)&#123;        sum[i] = a[i] + sum[i + 1];        endRecord[i] = endRecord[i + 1];    //情况2：当i + 1的数小于0时    //值为a数组本身的值    //结尾位置变为i    &#125;else&#123;        sum[i] = a[i];        endRecord[i] = i;        &#125;    &#125;    printf(&quot;累加和数组为：&quot;);    for(int i = 0;i &lt;= n ;i++)    printf(&quot;%d &quot;,sum[i]);    //查找结果函数    findResult(n,a,sum,endRecord);&#125;void findResult(int n,int a[],int sum[],int endRecord[])&#123;    int max,l,r,i;    //从左往右开始查找    //max初始化为sum数组第一个值    max = sum[0];    //和sum数组第二个值开始比对    for(i = 1;i &lt;= n;i++)&#123;    if(max &lt; sum[i])&#123;        max = sum[i];        l = i;        r = endRecord[i];    &#125;&#125;printf(&quot;\\n原数组为：&quot;);for(i = 0;i &lt;= n ; i++)    printf(&quot;%d &quot;,a[i]);printf(&quot;\\n最大字段和为：%d 开始位置的数组下标：%d 结束位置的数组下标：%d&quot;,max,l,r);&#125;int main()&#123;    //这里可以改为输入的方式    int n=11;\tint a[]=&#123;1,-2,4,5,-2,8,3,-2,6,3,7,-1&#125;;\tdynamicPlan(a,n);&#125;\n\n","categories":["算法设计与分析"],"tags":["算法","动态规划"]}]